// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commands.proto

#ifndef PROTOBUF_commands_2eproto__INCLUDED
#define PROTOBUF_commands_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace nl {
namespace flarb {
namespace crisis {
namespace communication {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_commands_2eproto();
void protobuf_AssignDesc_commands_2eproto();
void protobuf_ShutdownFile_commands_2eproto();

class Program;
class Position;
class Environment;
class Environment_Element;
class Environment_Crisis;
class Header;
class Command;

enum Program_ProgramType {
  Program_ProgramType_Tour = 1,
  Program_ProgramType_Navigate = 2,
  Program_ProgramType_FindDamaged = 3
};
bool Program_ProgramType_IsValid(int value);
const Program_ProgramType Program_ProgramType_ProgramType_MIN = Program_ProgramType_Tour;
const Program_ProgramType Program_ProgramType_ProgramType_MAX = Program_ProgramType_FindDamaged;
const int Program_ProgramType_ProgramType_ARRAYSIZE = Program_ProgramType_ProgramType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Program_ProgramType_descriptor();
inline const ::std::string& Program_ProgramType_Name(Program_ProgramType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Program_ProgramType_descriptor(), value);
}
inline bool Program_ProgramType_Parse(
    const ::std::string& name, Program_ProgramType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Program_ProgramType>(
    Program_ProgramType_descriptor(), name, value);
}
enum Program_Direction {
  Program_Direction_Left = 1,
  Program_Direction_Right = 2
};
bool Program_Direction_IsValid(int value);
const Program_Direction Program_Direction_Direction_MIN = Program_Direction_Left;
const Program_Direction Program_Direction_Direction_MAX = Program_Direction_Right;
const int Program_Direction_Direction_ARRAYSIZE = Program_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Program_Direction_descriptor();
inline const ::std::string& Program_Direction_Name(Program_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Program_Direction_descriptor(), value);
}
inline bool Program_Direction_Parse(
    const ::std::string& name, Program_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Program_Direction>(
    Program_Direction_descriptor(), name, value);
}
enum Environment_Element_Type {
  Environment_Element_Type_Sunflower = 1,
  Environment_Element_Type_DeadSunflower = 2,
  Environment_Element_Type_Weed = 3
};
bool Environment_Element_Type_IsValid(int value);
const Environment_Element_Type Environment_Element_Type_Type_MIN = Environment_Element_Type_Sunflower;
const Environment_Element_Type Environment_Element_Type_Type_MAX = Environment_Element_Type_Weed;
const int Environment_Element_Type_Type_ARRAYSIZE = Environment_Element_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Environment_Element_Type_descriptor();
inline const ::std::string& Environment_Element_Type_Name(Environment_Element_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Environment_Element_Type_descriptor(), value);
}
inline bool Environment_Element_Type_Parse(
    const ::std::string& name, Environment_Element_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Environment_Element_Type>(
    Environment_Element_Type_descriptor(), name, value);
}
enum Command_Type {
  Command_Type_Shutdown = 1,
  Command_Type_StartProgram = 2,
  Command_Type_Environment = 3,
  Command_Type_RestartROS = 4,
  Command_Type_AbortProgram = 5
};
bool Command_Type_IsValid(int value);
const Command_Type Command_Type_Type_MIN = Command_Type_Shutdown;
const Command_Type Command_Type_Type_MAX = Command_Type_AbortProgram;
const int Command_Type_Type_ARRAYSIZE = Command_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Type_descriptor();
inline const ::std::string& Command_Type_Name(Command_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Type_descriptor(), value);
}
inline bool Command_Type_Parse(
    const ::std::string& name, Command_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Type>(
    Command_Type_descriptor(), name, value);
}
// ===================================================================

class Program : public ::google::protobuf::Message {
 public:
  Program();
  virtual ~Program();
  
  Program(const Program& from);
  
  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Program& default_instance();
  
  void Swap(Program* other);
  
  // implements Message ----------------------------------------------
  
  Program* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Program_ProgramType ProgramType;
  static const ProgramType Tour = Program_ProgramType_Tour;
  static const ProgramType Navigate = Program_ProgramType_Navigate;
  static const ProgramType FindDamaged = Program_ProgramType_FindDamaged;
  static inline bool ProgramType_IsValid(int value) {
    return Program_ProgramType_IsValid(value);
  }
  static const ProgramType ProgramType_MIN =
    Program_ProgramType_ProgramType_MIN;
  static const ProgramType ProgramType_MAX =
    Program_ProgramType_ProgramType_MAX;
  static const int ProgramType_ARRAYSIZE =
    Program_ProgramType_ProgramType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProgramType_descriptor() {
    return Program_ProgramType_descriptor();
  }
  static inline const ::std::string& ProgramType_Name(ProgramType value) {
    return Program_ProgramType_Name(value);
  }
  static inline bool ProgramType_Parse(const ::std::string& name,
      ProgramType* value) {
    return Program_ProgramType_Parse(name, value);
  }
  
  typedef Program_Direction Direction;
  static const Direction Left = Program_Direction_Left;
  static const Direction Right = Program_Direction_Right;
  static inline bool Direction_IsValid(int value) {
    return Program_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Program_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Program_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Program_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Program_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Program_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Program_Direction_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .nl.flarb.crisis.communication.Program.ProgramType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nl::flarb::crisis::communication::Program_ProgramType type() const;
  inline void set_type(::nl::flarb::crisis::communication::Program_ProgramType value);
  
  // optional .nl.flarb.crisis.communication.Program.Direction first_turn = 2;
  inline bool has_first_turn() const;
  inline void clear_first_turn();
  static const int kFirstTurnFieldNumber = 2;
  inline ::nl::flarb::crisis::communication::Program_Direction first_turn() const;
  inline void set_first_turn(::nl::flarb::crisis::communication::Program_Direction value);
  
  // optional string directions = 3;
  inline bool has_directions() const;
  inline void clear_directions();
  static const int kDirectionsFieldNumber = 3;
  inline const ::std::string& directions() const;
  inline void set_directions(const ::std::string& value);
  inline void set_directions(const char* value);
  inline void set_directions(const char* value, size_t size);
  inline ::std::string* mutable_directions();
  inline ::std::string* release_directions();
  
  // @@protoc_insertion_point(class_scope:nl.flarb.crisis.communication.Program)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_first_turn();
  inline void clear_has_first_turn();
  inline void set_has_directions();
  inline void clear_has_directions();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  int first_turn_;
  ::std::string* directions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  void InitAsDefaultInstance();
  static Program* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();
  
  Position(const Position& from);
  
  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();
  
  void Swap(Position* other);
  
  // implements Message ----------------------------------------------
  
  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // required uint32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:nl.flarb.crisis.communication.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Environment_Element : public ::google::protobuf::Message {
 public:
  Environment_Element();
  virtual ~Environment_Element();
  
  Environment_Element(const Environment_Element& from);
  
  inline Environment_Element& operator=(const Environment_Element& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment_Element& default_instance();
  
  void Swap(Environment_Element* other);
  
  // implements Message ----------------------------------------------
  
  Environment_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment_Element& from);
  void MergeFrom(const Environment_Element& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Environment_Element_Type Type;
  static const Type Sunflower = Environment_Element_Type_Sunflower;
  static const Type DeadSunflower = Environment_Element_Type_DeadSunflower;
  static const Type Weed = Environment_Element_Type_Weed;
  static inline bool Type_IsValid(int value) {
    return Environment_Element_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Environment_Element_Type_Type_MIN;
  static const Type Type_MAX =
    Environment_Element_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Environment_Element_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Environment_Element_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Environment_Element_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Environment_Element_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .nl.flarb.crisis.communication.Environment.Element.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nl::flarb::crisis::communication::Environment_Element_Type type() const;
  inline void set_type(::nl::flarb::crisis::communication::Environment_Element_Type value);
  
  // required .nl.flarb.crisis.communication.Position pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline const ::nl::flarb::crisis::communication::Position& pos() const;
  inline ::nl::flarb::crisis::communication::Position* mutable_pos();
  inline ::nl::flarb::crisis::communication::Position* release_pos();
  
  // optional float size = 3 [default = 1];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline float size() const;
  inline void set_size(float value);
  
  // @@protoc_insertion_point(class_scope:nl.flarb.crisis.communication.Environment.Element)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::nl::flarb::crisis::communication::Position* pos_;
  int type_;
  float size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  void InitAsDefaultInstance();
  static Environment_Element* default_instance_;
};
// -------------------------------------------------------------------

class Environment_Crisis : public ::google::protobuf::Message {
 public:
  Environment_Crisis();
  virtual ~Environment_Crisis();
  
  Environment_Crisis(const Environment_Crisis& from);
  
  inline Environment_Crisis& operator=(const Environment_Crisis& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment_Crisis& default_instance();
  
  void Swap(Environment_Crisis* other);
  
  // implements Message ----------------------------------------------
  
  Environment_Crisis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment_Crisis& from);
  void MergeFrom(const Environment_Crisis& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .nl.flarb.crisis.communication.Position pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::nl::flarb::crisis::communication::Position& pos() const;
  inline ::nl::flarb::crisis::communication::Position* mutable_pos();
  inline ::nl::flarb::crisis::communication::Position* release_pos();
  
  // required float rotation = 2;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 2;
  inline float rotation() const;
  inline void set_rotation(float value);
  
  // @@protoc_insertion_point(class_scope:nl.flarb.crisis.communication.Environment.Crisis)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::nl::flarb::crisis::communication::Position* pos_;
  float rotation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  void InitAsDefaultInstance();
  static Environment_Crisis* default_instance_;
};
// -------------------------------------------------------------------

class Environment : public ::google::protobuf::Message {
 public:
  Environment();
  virtual ~Environment();
  
  Environment(const Environment& from);
  
  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment& default_instance();
  
  void Swap(Environment* other);
  
  // implements Message ----------------------------------------------
  
  Environment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment& from);
  void MergeFrom(const Environment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Environment_Element Element;
  typedef Environment_Crisis Crisis;
  
  // accessors -------------------------------------------------------
  
  // repeated .nl.flarb.crisis.communication.Environment.Element elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::nl::flarb::crisis::communication::Environment_Element& elements(int index) const;
  inline ::nl::flarb::crisis::communication::Environment_Element* mutable_elements(int index);
  inline ::nl::flarb::crisis::communication::Environment_Element* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::nl::flarb::crisis::communication::Environment_Element >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::nl::flarb::crisis::communication::Environment_Element >*
      mutable_elements();
  
  // required .nl.flarb.crisis.communication.Environment.Crisis crisis = 2;
  inline bool has_crisis() const;
  inline void clear_crisis();
  static const int kCrisisFieldNumber = 2;
  inline const ::nl::flarb::crisis::communication::Environment_Crisis& crisis() const;
  inline ::nl::flarb::crisis::communication::Environment_Crisis* mutable_crisis();
  inline ::nl::flarb::crisis::communication::Environment_Crisis* release_crisis();
  
  // required .nl.flarb.crisis.communication.Position field_size = 3;
  inline bool has_field_size() const;
  inline void clear_field_size();
  static const int kFieldSizeFieldNumber = 3;
  inline const ::nl::flarb::crisis::communication::Position& field_size() const;
  inline ::nl::flarb::crisis::communication::Position* mutable_field_size();
  inline ::nl::flarb::crisis::communication::Position* release_field_size();
  
  // @@protoc_insertion_point(class_scope:nl.flarb.crisis.communication.Environment)
 private:
  inline void set_has_crisis();
  inline void clear_has_crisis();
  inline void set_has_field_size();
  inline void clear_has_field_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::nl::flarb::crisis::communication::Environment_Element > elements_;
  ::nl::flarb::crisis::communication::Environment_Crisis* crisis_;
  ::nl::flarb::crisis::communication::Position* field_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  void InitAsDefaultInstance();
  static Environment* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();
  
  Header(const Header& from);
  
  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();
  
  void Swap(Header* other);
  
  // implements Message ----------------------------------------------
  
  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed32 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:nl.flarb.crisis.communication.Header)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();
  
  Command(const Command& from);
  
  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();
  
  void Swap(Command* other);
  
  // implements Message ----------------------------------------------
  
  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Command_Type Type;
  static const Type Shutdown = Command_Type_Shutdown;
  static const Type StartProgram = Command_Type_StartProgram;
  static const Type Environment = Command_Type_Environment;
  static const Type RestartROS = Command_Type_RestartROS;
  static const Type AbortProgram = Command_Type_AbortProgram;
  static inline bool Type_IsValid(int value) {
    return Command_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Command_Type_Type_MIN;
  static const Type Type_MAX =
    Command_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Command_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Command_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Command_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Command_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .nl.flarb.crisis.communication.Command.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::nl::flarb::crisis::communication::Command_Type type() const;
  inline void set_type(::nl::flarb::crisis::communication::Command_Type value);
  
  // optional .nl.flarb.crisis.communication.Program program = 2;
  inline bool has_program() const;
  inline void clear_program();
  static const int kProgramFieldNumber = 2;
  inline const ::nl::flarb::crisis::communication::Program& program() const;
  inline ::nl::flarb::crisis::communication::Program* mutable_program();
  inline ::nl::flarb::crisis::communication::Program* release_program();
  
  // optional .nl.flarb.crisis.communication.Environment env = 3;
  inline bool has_env() const;
  inline void clear_env();
  static const int kEnvFieldNumber = 3;
  inline const ::nl::flarb::crisis::communication::Environment& env() const;
  inline ::nl::flarb::crisis::communication::Environment* mutable_env();
  inline ::nl::flarb::crisis::communication::Environment* release_env();
  
  // @@protoc_insertion_point(class_scope:nl.flarb.crisis.communication.Command)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_program();
  inline void clear_has_program();
  inline void set_has_env();
  inline void clear_has_env();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::nl::flarb::crisis::communication::Program* program_;
  ::nl::flarb::crisis::communication::Environment* env_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// ===================================================================


// ===================================================================

// Program

// required .nl.flarb.crisis.communication.Program.ProgramType type = 1;
inline bool Program::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Program::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Program::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Program::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::nl::flarb::crisis::communication::Program_ProgramType Program::type() const {
  return static_cast< ::nl::flarb::crisis::communication::Program_ProgramType >(type_);
}
inline void Program::set_type(::nl::flarb::crisis::communication::Program_ProgramType value) {
  GOOGLE_DCHECK(::nl::flarb::crisis::communication::Program_ProgramType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .nl.flarb.crisis.communication.Program.Direction first_turn = 2;
inline bool Program::has_first_turn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Program::set_has_first_turn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Program::clear_has_first_turn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Program::clear_first_turn() {
  first_turn_ = 1;
  clear_has_first_turn();
}
inline ::nl::flarb::crisis::communication::Program_Direction Program::first_turn() const {
  return static_cast< ::nl::flarb::crisis::communication::Program_Direction >(first_turn_);
}
inline void Program::set_first_turn(::nl::flarb::crisis::communication::Program_Direction value) {
  GOOGLE_DCHECK(::nl::flarb::crisis::communication::Program_Direction_IsValid(value));
  set_has_first_turn();
  first_turn_ = value;
}

// optional string directions = 3;
inline bool Program::has_directions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Program::set_has_directions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Program::clear_has_directions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Program::clear_directions() {
  if (directions_ != &::google::protobuf::internal::kEmptyString) {
    directions_->clear();
  }
  clear_has_directions();
}
inline const ::std::string& Program::directions() const {
  return *directions_;
}
inline void Program::set_directions(const ::std::string& value) {
  set_has_directions();
  if (directions_ == &::google::protobuf::internal::kEmptyString) {
    directions_ = new ::std::string;
  }
  directions_->assign(value);
}
inline void Program::set_directions(const char* value) {
  set_has_directions();
  if (directions_ == &::google::protobuf::internal::kEmptyString) {
    directions_ = new ::std::string;
  }
  directions_->assign(value);
}
inline void Program::set_directions(const char* value, size_t size) {
  set_has_directions();
  if (directions_ == &::google::protobuf::internal::kEmptyString) {
    directions_ = new ::std::string;
  }
  directions_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Program::mutable_directions() {
  set_has_directions();
  if (directions_ == &::google::protobuf::internal::kEmptyString) {
    directions_ = new ::std::string;
  }
  return directions_;
}
inline ::std::string* Program::release_directions() {
  clear_has_directions();
  if (directions_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = directions_;
    directions_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Position

// required uint32 x = 1;
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 Position::x() const {
  return x_;
}
inline void Position::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// required uint32 y = 2;
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 Position::y() const {
  return y_;
}
inline void Position::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Environment_Element

// required .nl.flarb.crisis.communication.Environment.Element.Type type = 1;
inline bool Environment_Element::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment_Element::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment_Element::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Environment_Element::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::nl::flarb::crisis::communication::Environment_Element_Type Environment_Element::type() const {
  return static_cast< ::nl::flarb::crisis::communication::Environment_Element_Type >(type_);
}
inline void Environment_Element::set_type(::nl::flarb::crisis::communication::Environment_Element_Type value) {
  GOOGLE_DCHECK(::nl::flarb::crisis::communication::Environment_Element_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .nl.flarb.crisis.communication.Position pos = 2;
inline bool Environment_Element::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment_Element::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment_Element::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment_Element::clear_pos() {
  if (pos_ != NULL) pos_->::nl::flarb::crisis::communication::Position::Clear();
  clear_has_pos();
}
inline const ::nl::flarb::crisis::communication::Position& Environment_Element::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::nl::flarb::crisis::communication::Position* Environment_Element::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::nl::flarb::crisis::communication::Position;
  return pos_;
}
inline ::nl::flarb::crisis::communication::Position* Environment_Element::release_pos() {
  clear_has_pos();
  ::nl::flarb::crisis::communication::Position* temp = pos_;
  pos_ = NULL;
  return temp;
}

// optional float size = 3 [default = 1];
inline bool Environment_Element::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Environment_Element::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Environment_Element::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Environment_Element::clear_size() {
  size_ = 1;
  clear_has_size();
}
inline float Environment_Element::size() const {
  return size_;
}
inline void Environment_Element::set_size(float value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Environment_Crisis

// required .nl.flarb.crisis.communication.Position pos = 1;
inline bool Environment_Crisis::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment_Crisis::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment_Crisis::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Environment_Crisis::clear_pos() {
  if (pos_ != NULL) pos_->::nl::flarb::crisis::communication::Position::Clear();
  clear_has_pos();
}
inline const ::nl::flarb::crisis::communication::Position& Environment_Crisis::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::nl::flarb::crisis::communication::Position* Environment_Crisis::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::nl::flarb::crisis::communication::Position;
  return pos_;
}
inline ::nl::flarb::crisis::communication::Position* Environment_Crisis::release_pos() {
  clear_has_pos();
  ::nl::flarb::crisis::communication::Position* temp = pos_;
  pos_ = NULL;
  return temp;
}

// required float rotation = 2;
inline bool Environment_Crisis::has_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment_Crisis::set_has_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment_Crisis::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment_Crisis::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float Environment_Crisis::rotation() const {
  return rotation_;
}
inline void Environment_Crisis::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// -------------------------------------------------------------------

// Environment

// repeated .nl.flarb.crisis.communication.Environment.Element elements = 1;
inline int Environment::elements_size() const {
  return elements_.size();
}
inline void Environment::clear_elements() {
  elements_.Clear();
}
inline const ::nl::flarb::crisis::communication::Environment_Element& Environment::elements(int index) const {
  return elements_.Get(index);
}
inline ::nl::flarb::crisis::communication::Environment_Element* Environment::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::nl::flarb::crisis::communication::Environment_Element* Environment::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nl::flarb::crisis::communication::Environment_Element >&
Environment::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::nl::flarb::crisis::communication::Environment_Element >*
Environment::mutable_elements() {
  return &elements_;
}

// required .nl.flarb.crisis.communication.Environment.Crisis crisis = 2;
inline bool Environment::has_crisis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment::set_has_crisis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment::clear_has_crisis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment::clear_crisis() {
  if (crisis_ != NULL) crisis_->::nl::flarb::crisis::communication::Environment_Crisis::Clear();
  clear_has_crisis();
}
inline const ::nl::flarb::crisis::communication::Environment_Crisis& Environment::crisis() const {
  return crisis_ != NULL ? *crisis_ : *default_instance_->crisis_;
}
inline ::nl::flarb::crisis::communication::Environment_Crisis* Environment::mutable_crisis() {
  set_has_crisis();
  if (crisis_ == NULL) crisis_ = new ::nl::flarb::crisis::communication::Environment_Crisis;
  return crisis_;
}
inline ::nl::flarb::crisis::communication::Environment_Crisis* Environment::release_crisis() {
  clear_has_crisis();
  ::nl::flarb::crisis::communication::Environment_Crisis* temp = crisis_;
  crisis_ = NULL;
  return temp;
}

// required .nl.flarb.crisis.communication.Position field_size = 3;
inline bool Environment::has_field_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Environment::set_has_field_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Environment::clear_has_field_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Environment::clear_field_size() {
  if (field_size_ != NULL) field_size_->::nl::flarb::crisis::communication::Position::Clear();
  clear_has_field_size();
}
inline const ::nl::flarb::crisis::communication::Position& Environment::field_size() const {
  return field_size_ != NULL ? *field_size_ : *default_instance_->field_size_;
}
inline ::nl::flarb::crisis::communication::Position* Environment::mutable_field_size() {
  set_has_field_size();
  if (field_size_ == NULL) field_size_ = new ::nl::flarb::crisis::communication::Position;
  return field_size_;
}
inline ::nl::flarb::crisis::communication::Position* Environment::release_field_size() {
  clear_has_field_size();
  ::nl::flarb::crisis::communication::Position* temp = field_size_;
  field_size_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Header

// required fixed32 size = 1;
inline bool Header::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 Header::size() const {
  return size_;
}
inline void Header::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Command

// required .nl.flarb.crisis.communication.Command.Type type = 1;
inline bool Command::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::nl::flarb::crisis::communication::Command_Type Command::type() const {
  return static_cast< ::nl::flarb::crisis::communication::Command_Type >(type_);
}
inline void Command::set_type(::nl::flarb::crisis::communication::Command_Type value) {
  GOOGLE_DCHECK(::nl::flarb::crisis::communication::Command_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .nl.flarb.crisis.communication.Program program = 2;
inline bool Command::has_program() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_program() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_program() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_program() {
  if (program_ != NULL) program_->::nl::flarb::crisis::communication::Program::Clear();
  clear_has_program();
}
inline const ::nl::flarb::crisis::communication::Program& Command::program() const {
  return program_ != NULL ? *program_ : *default_instance_->program_;
}
inline ::nl::flarb::crisis::communication::Program* Command::mutable_program() {
  set_has_program();
  if (program_ == NULL) program_ = new ::nl::flarb::crisis::communication::Program;
  return program_;
}
inline ::nl::flarb::crisis::communication::Program* Command::release_program() {
  clear_has_program();
  ::nl::flarb::crisis::communication::Program* temp = program_;
  program_ = NULL;
  return temp;
}

// optional .nl.flarb.crisis.communication.Environment env = 3;
inline bool Command::has_env() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_env() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_env() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_env() {
  if (env_ != NULL) env_->::nl::flarb::crisis::communication::Environment::Clear();
  clear_has_env();
}
inline const ::nl::flarb::crisis::communication::Environment& Command::env() const {
  return env_ != NULL ? *env_ : *default_instance_->env_;
}
inline ::nl::flarb::crisis::communication::Environment* Command::mutable_env() {
  set_has_env();
  if (env_ == NULL) env_ = new ::nl::flarb::crisis::communication::Environment;
  return env_;
}
inline ::nl::flarb::crisis::communication::Environment* Command::release_env() {
  clear_has_env();
  ::nl::flarb::crisis::communication::Environment* temp = env_;
  env_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace communication
}  // namespace crisis
}  // namespace flarb
}  // namespace nl

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nl::flarb::crisis::communication::Program_ProgramType>() {
  return ::nl::flarb::crisis::communication::Program_ProgramType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nl::flarb::crisis::communication::Program_Direction>() {
  return ::nl::flarb::crisis::communication::Program_Direction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nl::flarb::crisis::communication::Environment_Element_Type>() {
  return ::nl::flarb::crisis::communication::Environment_Element_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nl::flarb::crisis::communication::Command_Type>() {
  return ::nl::flarb::crisis::communication::Command_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_commands_2eproto__INCLUDED
